{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOptions = void 0;\n\nconst bip39_1 = require(\"ethereum-cryptography/bip39\");\n\nconst english_1 = require(\"ethereum-cryptography/bip39/wordlists/english\"); // check that the first argument is a mnemonic phrase\n\n\nconst isMnemonicPhrase = credentials => typeof credentials === \"string\" && bip39_1.validateMnemonic(credentials, english_1.wordlist); // check that the first argument is a list of private keys\n\n\nconst isPrivateKeys = credentials => credentials instanceof Array; // check that the first argument is a single private key (default case for invalid mnemonics)\n\n\nconst isPrivateKey = credentials => !isPrivateKeys(credentials) && !isMnemonicPhrase(credentials); // turn polymorphic first argument into { mnemonic } or { privateKeys }\n\n\nconst getSigningAuthorityOptions = credentials => {\n  if (isMnemonicPhrase(credentials)) {\n    return {\n      mnemonic: {\n        phrase: credentials\n      }\n    };\n  } else if (isPrivateKeys(credentials)) {\n    return {\n      privateKeys: credentials\n    };\n  } else if (isPrivateKey(credentials)) {\n    // if(...) included for explicitness\n    return {\n      privateKeys: [credentials]\n    };\n  } else {\n    // this won't be reached until/unless we validate private key(s)\n    throw new Error(`First argument to new HDWalletProvider() must be a mnemonic phrase, a ` + `single private key, or a list of private keys. ` + `Received: ${JSON.stringify(credentials)}`);\n  }\n};\n\nconst fromInputOptions = options => {\n  if (\"mnemonic\" in options && typeof options.mnemonic === \"string\") {\n    return Object.assign(Object.assign({}, options), {\n      mnemonic: {\n        phrase: options.mnemonic\n      }\n    });\n  } else {\n    return options;\n  }\n}; // convert legacy style positional arguments to new, single-arg options format\n\n\nconst fromArguments = args => {\n  // otherwise, if arguments match the old-style, extract properties and handle polymorphism\n  const [mnemonicPhraseOrPrivateKeys, providerOrUrl, addressIndex, numberOfAddresses, shareNonce, derivationPath, chainId] = args;\n  const signingAuthority = getSigningAuthorityOptions(mnemonicPhraseOrPrivateKeys);\n  return Object.assign(Object.assign({}, signingAuthority), {\n    providerOrUrl,\n    addressIndex,\n    numberOfAddresses,\n    shareNonce,\n    derivationPath,\n    chainId\n  });\n}; // type predicate guard to determine at runtime if arguments conform to\n// new-style constructor args.\n\n\nconst matchesNewInputOptions = args => {\n  // new-style means exactly one argument\n  if (args.length !== 1) {\n    return false;\n  }\n\n  const [options] = args; // beyond that, determine based on property inclusion check for required keys\n\n  return \"providerOrUrl\" in options && (\"privateKeys\" in options || \"mnemonic\" in options);\n}; // type predicate guard to determine at runtime if arguments conform to\n// old-style constructor args.\n\n\nconst matchesLegacyArguments = args => // first check for alternate (new-style) case for basic determination\n!matchesNewInputOptions(args) && // then additionally make sure we have the two required options we need\nargs.filter(arg => arg !== undefined).length >= 2; // normalize arguments passed to constructor to match single, new-style options\n// argument\n\n\nconst getOptions = (...args) => {\n  if (matchesNewInputOptions(args)) {\n    // if arguments already match new-style, no real transformation needed\n    const [options] = args;\n    return fromInputOptions(options);\n  } else if (matchesLegacyArguments(args)) {\n    return fromArguments(args);\n  } else {\n    throw new Error(\"Unknown arguments format passed to new HDWalletProvider. Please check your configuration and try again\");\n  }\n};\n\nexports.getOptions = getOptions;","map":{"version":3,"sources":["../../src/constructor/getOptions.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getOptions = void 0;\nconst bip39_1 = require(\"ethereum-cryptography/bip39\");\nconst english_1 = require(\"ethereum-cryptography/bip39/wordlists/english\");\n// check that the first argument is a mnemonic phrase\nconst isMnemonicPhrase = (credentials) => typeof credentials === \"string\" &&\n    bip39_1.validateMnemonic(credentials, english_1.wordlist);\n// check that the first argument is a list of private keys\nconst isPrivateKeys = (credentials) => credentials instanceof Array;\n// check that the first argument is a single private key (default case for invalid mnemonics)\nconst isPrivateKey = (credentials) => !isPrivateKeys(credentials) &&\n    !isMnemonicPhrase(credentials);\n// turn polymorphic first argument into { mnemonic } or { privateKeys }\nconst getSigningAuthorityOptions = (credentials) => {\n    if (isMnemonicPhrase(credentials)) {\n        return {\n            mnemonic: {\n                phrase: credentials\n            }\n        };\n    }\n    else if (isPrivateKeys(credentials)) {\n        return {\n            privateKeys: credentials\n        };\n    }\n    else if (isPrivateKey(credentials)) { // if(...) included for explicitness\n        return {\n            privateKeys: [credentials]\n        };\n    }\n    else { // this won't be reached until/unless we validate private key(s)\n        throw new Error(`First argument to new HDWalletProvider() must be a mnemonic phrase, a ` +\n            `single private key, or a list of private keys. ` +\n            `Received: ${JSON.stringify(credentials)}`);\n    }\n};\nconst fromInputOptions = (options) => {\n    if (\"mnemonic\" in options && typeof options.mnemonic === \"string\") {\n        return Object.assign(Object.assign({}, options), { mnemonic: {\n                phrase: options.mnemonic\n            } });\n    }\n    else {\n        return options;\n    }\n};\n// convert legacy style positional arguments to new, single-arg options format\nconst fromArguments = (args) => {\n    // otherwise, if arguments match the old-style, extract properties and handle polymorphism\n    const [mnemonicPhraseOrPrivateKeys, providerOrUrl, addressIndex, numberOfAddresses, shareNonce, derivationPath, chainId] = args;\n    const signingAuthority = getSigningAuthorityOptions(mnemonicPhraseOrPrivateKeys);\n    return Object.assign(Object.assign({}, signingAuthority), { providerOrUrl,\n        addressIndex,\n        numberOfAddresses,\n        shareNonce,\n        derivationPath,\n        chainId });\n};\n// type predicate guard to determine at runtime if arguments conform to\n// new-style constructor args.\nconst matchesNewInputOptions = (args) => {\n    // new-style means exactly one argument\n    if (args.length !== 1) {\n        return false;\n    }\n    const [options] = args;\n    // beyond that, determine based on property inclusion check for required keys\n    return (\"providerOrUrl\" in options &&\n        (\"privateKeys\" in options || \"mnemonic\" in options));\n};\n// type predicate guard to determine at runtime if arguments conform to\n// old-style constructor args.\nconst matchesLegacyArguments = (args) => \n// first check for alternate (new-style) case for basic determination\n!matchesNewInputOptions(args) &&\n    // then additionally make sure we have the two required options we need\n    args.filter(arg => arg !== undefined).length >= 2;\n// normalize arguments passed to constructor to match single, new-style options\n// argument\nconst getOptions = (...args) => {\n    if (matchesNewInputOptions(args)) {\n        // if arguments already match new-style, no real transformation needed\n        const [options] = args;\n        return fromInputOptions(options);\n    }\n    else if (matchesLegacyArguments(args)) {\n        return fromArguments(args);\n    }\n    else {\n        throw new Error(\"Unknown arguments format passed to new HDWalletProvider. Please check your configuration and try again\");\n    }\n};\nexports.getOptions = getOptions;\n//# sourceMappingURL=getOptions.js.map"]},"metadata":{},"sourceType":"script"}