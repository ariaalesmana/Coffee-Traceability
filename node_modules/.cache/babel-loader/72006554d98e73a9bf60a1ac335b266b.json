{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nconst bip39 = __importStar(require(\"ethereum-cryptography/bip39\"));\n\nconst english_1 = require(\"ethereum-cryptography/bip39/wordlists/english\");\n\nconst EthUtil = __importStar(require(\"ethereumjs-util\"));\n\nconst ethereumjs_wallet_1 = __importDefault(require(\"ethereumjs-wallet\"));\n\nconst ethereumjs_wallet_2 = require(\"ethereumjs-wallet\");\n\nconst ethereumjs_tx_1 = require(\"ethereumjs-tx\");\n\nconst ethereumjs_common_1 = __importDefault(require(\"ethereumjs-common\")); // @ts-ignore\n\n\nconst web3_provider_engine_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine\"));\n\nconst filters_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/filters\"));\n\nconst nonce_tracker_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/nonce-tracker\"));\n\nconst hooked_wallet_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/hooked-wallet\"));\n\nconst provider_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/provider\")); // @ts-ignore\n\n\nconst rpc_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/rpc\")); // @ts-ignore\n\n\nconst websocket_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/websocket\"));\n\nconst url_1 = __importDefault(require(\"url\"));\n\nconst getOptions_1 = require(\"./constructor/getOptions\");\n\nconst getPrivateKeys_1 = require(\"./constructor/getPrivateKeys\");\n\nconst getMnemonic_1 = require(\"./constructor/getMnemonic\"); // Important: do not use debug module. Reason: https://github.com/trufflesuite/truffle/issues/2374#issuecomment-536109086\n// This line shares nonce state across multiple provider instances. Necessary\n// because within truffle the wallet is repeatedly newed if it's declared in the config within a\n// function, resetting nonce from tx to tx. An instance can opt out\n// of this behavior by passing `shareNonce=false` to the constructor.\n// See issue #65 for more\n\n\nconst singletonNonceSubProvider = new nonce_tracker_1.default();\n\nclass HDWalletProvider {\n  constructor(...args) {\n    const _a = getOptions_1.getOptions(...args),\n          {\n      providerOrUrl,\n      // required\n      addressIndex = 0,\n      numberOfAddresses = 10,\n      shareNonce = true,\n      derivationPath = `m/44'/60'/0'/0/`,\n      pollingInterval = 4000,\n      chainId,\n      chainSettings = {}\n    } = _a,\n          // what's left is either a mnemonic or a list of private keys\n    signingAuthority = __rest(_a, [\"providerOrUrl\", \"addressIndex\", \"numberOfAddresses\", \"shareNonce\", \"derivationPath\", \"pollingInterval\", \"chainId\", \"chainSettings\"]);\n\n    const mnemonic = getMnemonic_1.getMnemonic(signingAuthority);\n    const privateKeys = getPrivateKeys_1.getPrivateKeys(signingAuthority);\n    this.walletHdpath = derivationPath;\n    this.wallets = {};\n    this.addresses = [];\n    this.chainSettings = chainSettings;\n    this.engine = new web3_provider_engine_1.default({\n      pollingInterval\n    });\n\n    if (!HDWalletProvider.isValidProvider(providerOrUrl)) {\n      throw new Error([`Malformed provider URL: '${providerOrUrl}'`, \"Please specify a correct URL, using the http, https, ws, or wss protocol.\", \"\"].join(\"\\n\"));\n    }\n\n    if (mnemonic && mnemonic.phrase) {\n      this.checkBIP39Mnemonic(Object.assign(Object.assign({}, mnemonic), {\n        addressIndex,\n        numberOfAddresses\n      }));\n    } else if (privateKeys) {\n      const options = Object.assign({}, {\n        privateKeys\n      }, {\n        addressIndex\n      });\n      this.ethUtilValidation(options);\n    } // no need to handle else case here, since matchesNewOptions() covers it\n\n\n    if (this.addresses.length === 0) {\n      throw new Error(`Could not create addresses from your mnemonic or private key(s). ` + `Please check that your inputs are correct.`);\n    }\n\n    const tmpAccounts = this.addresses;\n    const tmpWallets = this.wallets; // if user supplied the chain id, use that - otherwise fetch it\n\n    if (typeof chainId !== \"undefined\" || chainSettings && typeof chainSettings.chainId !== \"undefined\") {\n      this.chainId = chainId || chainSettings.chainId;\n      this.initialized = Promise.resolve();\n    } else {\n      this.initialized = this.initialize();\n    } // EIP155 compliant transactions are enabled for hardforks later\n    // than or equal to \"spurious dragon\"\n\n\n    this.hardfork = chainSettings && chainSettings.hardfork ? chainSettings.hardfork : \"istanbul\";\n    const self = this;\n    this.engine.addProvider(new hooked_wallet_1.default({\n      getAccounts(cb) {\n        cb(null, tmpAccounts);\n      },\n\n      getPrivateKey(address, cb) {\n        if (!tmpWallets[address]) {\n          return cb(\"Account not found\");\n        } else {\n          cb(null, tmpWallets[address].getPrivateKey().toString(\"hex\"));\n        }\n      },\n\n      signTransaction(txParams, cb) {\n        return __awaiter(this, void 0, void 0, function* () {\n          yield self.initialized; // we need to rename the 'gas' field\n\n          txParams.gasLimit = txParams.gas;\n          delete txParams.gas;\n          let pkey;\n          const from = txParams.from.toLowerCase();\n\n          if (tmpWallets[from]) {\n            pkey = tmpWallets[from].getPrivateKey();\n          } else {\n            cb(\"Account not found\");\n          }\n\n          const chain = self.chainId;\n          const KNOWN_CHAIN_IDS = new Set([1, 3, 4, 5, 42]);\n          let txOptions;\n\n          if (typeof chain !== \"undefined\" && KNOWN_CHAIN_IDS.has(chain)) {\n            txOptions = {\n              chain\n            };\n          } else if (typeof chain !== \"undefined\") {\n            const common = ethereumjs_common_1.default.forCustomChain(1, {\n              name: \"custom chain\",\n              chainId: chain\n            }, self.hardfork);\n            txOptions = {\n              common\n            };\n          }\n\n          const tx = new ethereumjs_tx_1.Transaction(txParams, txOptions);\n          tx.sign(pkey);\n          const rawTx = `0x${tx.serialize().toString(\"hex\")}`;\n          cb(null, rawTx);\n        });\n      },\n\n      signMessage({\n        data,\n        from\n      }, cb) {\n        const dataIfExists = data;\n\n        if (!dataIfExists) {\n          cb(\"No data to sign\");\n        }\n\n        if (!tmpWallets[from]) {\n          cb(\"Account not found\");\n        }\n\n        let pkey = tmpWallets[from].getPrivateKey();\n        const dataBuff = EthUtil.toBuffer(dataIfExists);\n        const msgHashBuff = EthUtil.hashPersonalMessage(dataBuff);\n        const sig = EthUtil.ecsign(msgHashBuff, pkey);\n        const rpcSig = EthUtil.toRpcSig(sig.v, sig.r, sig.s);\n        cb(null, rpcSig);\n      },\n\n      signPersonalMessage(...args) {\n        this.signMessage(...args);\n      }\n\n    }));\n    !shareNonce ? this.engine.addProvider(new nonce_tracker_1.default()) : this.engine.addProvider(singletonNonceSubProvider);\n    this.engine.addProvider(new filters_1.default());\n\n    if (typeof providerOrUrl === \"string\") {\n      const url = providerOrUrl;\n      const providerProtocol = (url_1.default.parse(url).protocol || \"http:\").toLowerCase();\n\n      switch (providerProtocol) {\n        case \"ws:\":\n        case \"wss:\":\n          this.engine.addProvider(new websocket_1.default({\n            rpcUrl: url\n          }));\n          break;\n\n        default:\n          this.engine.addProvider(new rpc_1.default({\n            rpcUrl: url\n          }));\n      }\n    } else {\n      const provider = providerOrUrl;\n      this.engine.addProvider(new provider_1.default(provider));\n    } // Required by the provider engine.\n\n\n    this.engine.start(err => {\n      if (err) throw err;\n    });\n  }\n\n  initialize() {\n    return new Promise((resolve, reject) => {\n      this.engine.sendAsync({\n        jsonrpc: '2.0',\n        id: Date.now(),\n        method: 'eth_chainId',\n        params: []\n      }, (error, response) => {\n        if (error) {\n          reject(error);\n          return;\n        } else if (response.error) {\n          reject(response.error);\n          return;\n        }\n\n        if (isNaN(parseInt(response.result, 16))) {\n          const message = \"When requesting the chain id from the node, it\" + `returned the malformed result ${response.result}.`;\n          throw new Error(message);\n        }\n\n        this.chainId = parseInt(response.result, 16);\n        resolve();\n      });\n    });\n  } // private helper to check if given mnemonic uses BIP39 passphrase protection\n\n\n  checkBIP39Mnemonic({\n    addressIndex,\n    numberOfAddresses,\n    phrase,\n    password\n  }) {\n    this.hdwallet = ethereumjs_wallet_2.hdkey.fromMasterSeed(bip39.mnemonicToSeedSync(phrase, password));\n\n    if (!bip39.validateMnemonic(phrase, english_1.wordlist)) {\n      throw new Error(\"Mnemonic invalid or undefined\");\n    } // crank the addresses out\n\n\n    for (let i = addressIndex; i < addressIndex + numberOfAddresses; i++) {\n      const wallet = this.hdwallet.derivePath(this.walletHdpath + i).getWallet();\n      const addr = `0x${wallet.getAddress().toString(\"hex\")}`;\n      this.addresses.push(addr);\n      this.wallets[addr] = wallet;\n    }\n  } // private helper leveraging ethUtils to populate wallets/addresses\n\n\n  ethUtilValidation({\n    addressIndex,\n    privateKeys\n  }) {\n    // crank the addresses out\n    for (let i = addressIndex; i < privateKeys.length; i++) {\n      const privateKey = Buffer.from(privateKeys[i].replace(\"0x\", \"\"), \"hex\");\n\n      if (EthUtil.isValidPrivate(privateKey)) {\n        const wallet = ethereumjs_wallet_1.default.fromPrivateKey(privateKey);\n        const address = wallet.getAddressString();\n        this.addresses.push(address);\n        this.wallets[address] = wallet;\n      }\n    }\n  }\n\n  send(payload, callback) {\n    this.initialized.then(() => {\n      this.engine.send(payload, callback);\n    });\n  }\n\n  sendAsync(payload, callback) {\n    this.initialized.then(() => {\n      this.engine.sendAsync(payload, callback);\n    });\n  }\n\n  getAddress(idx) {\n    if (!idx) {\n      return this.addresses[0];\n    } else {\n      return this.addresses[idx];\n    }\n  }\n\n  getAddresses() {\n    return this.addresses;\n  }\n\n  static isValidProvider(provider) {\n    const validProtocols = [\"http:\", \"https:\", \"ws:\", \"wss:\"];\n\n    if (typeof provider === \"string\") {\n      const url = url_1.default.parse(provider.toLowerCase());\n      return !!(validProtocols.includes(url.protocol || \"\") && url.slashes);\n    }\n\n    return true;\n  }\n\n}\n\nmodule.exports = HDWalletProvider;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst bip39 = __importStar(require(\"ethereum-cryptography/bip39\"));\nconst english_1 = require(\"ethereum-cryptography/bip39/wordlists/english\");\nconst EthUtil = __importStar(require(\"ethereumjs-util\"));\nconst ethereumjs_wallet_1 = __importDefault(require(\"ethereumjs-wallet\"));\nconst ethereumjs_wallet_2 = require(\"ethereumjs-wallet\");\nconst ethereumjs_tx_1 = require(\"ethereumjs-tx\");\nconst ethereumjs_common_1 = __importDefault(require(\"ethereumjs-common\"));\n// @ts-ignore\nconst web3_provider_engine_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine\"));\nconst filters_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/filters\"));\nconst nonce_tracker_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/nonce-tracker\"));\nconst hooked_wallet_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/hooked-wallet\"));\nconst provider_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/provider\"));\n// @ts-ignore\nconst rpc_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/rpc\"));\n// @ts-ignore\nconst websocket_1 = __importDefault(require(\"@trufflesuite/web3-provider-engine/subproviders/websocket\"));\nconst url_1 = __importDefault(require(\"url\"));\nconst getOptions_1 = require(\"./constructor/getOptions\");\nconst getPrivateKeys_1 = require(\"./constructor/getPrivateKeys\");\nconst getMnemonic_1 = require(\"./constructor/getMnemonic\");\n// Important: do not use debug module. Reason: https://github.com/trufflesuite/truffle/issues/2374#issuecomment-536109086\n// This line shares nonce state across multiple provider instances. Necessary\n// because within truffle the wallet is repeatedly newed if it's declared in the config within a\n// function, resetting nonce from tx to tx. An instance can opt out\n// of this behavior by passing `shareNonce=false` to the constructor.\n// See issue #65 for more\nconst singletonNonceSubProvider = new nonce_tracker_1.default();\nclass HDWalletProvider {\n    constructor(...args) {\n        const _a = getOptions_1.getOptions(...args), { providerOrUrl, // required\n        addressIndex = 0, numberOfAddresses = 10, shareNonce = true, derivationPath = `m/44'/60'/0'/0/`, pollingInterval = 4000, chainId, chainSettings = {} } = _a, \n        // what's left is either a mnemonic or a list of private keys\n        signingAuthority = __rest(_a, [\"providerOrUrl\", \"addressIndex\", \"numberOfAddresses\", \"shareNonce\", \"derivationPath\", \"pollingInterval\", \"chainId\", \"chainSettings\"]);\n        const mnemonic = getMnemonic_1.getMnemonic(signingAuthority);\n        const privateKeys = getPrivateKeys_1.getPrivateKeys(signingAuthority);\n        this.walletHdpath = derivationPath;\n        this.wallets = {};\n        this.addresses = [];\n        this.chainSettings = chainSettings;\n        this.engine = new web3_provider_engine_1.default({\n            pollingInterval\n        });\n        if (!HDWalletProvider.isValidProvider(providerOrUrl)) {\n            throw new Error([\n                `Malformed provider URL: '${providerOrUrl}'`,\n                \"Please specify a correct URL, using the http, https, ws, or wss protocol.\",\n                \"\"\n            ].join(\"\\n\"));\n        }\n        if (mnemonic && mnemonic.phrase) {\n            this.checkBIP39Mnemonic(Object.assign(Object.assign({}, mnemonic), { addressIndex,\n                numberOfAddresses }));\n        }\n        else if (privateKeys) {\n            const options = Object.assign({}, { privateKeys }, { addressIndex });\n            this.ethUtilValidation(options);\n        } // no need to handle else case here, since matchesNewOptions() covers it\n        if (this.addresses.length === 0) {\n            throw new Error(`Could not create addresses from your mnemonic or private key(s). ` +\n                `Please check that your inputs are correct.`);\n        }\n        const tmpAccounts = this.addresses;\n        const tmpWallets = this.wallets;\n        // if user supplied the chain id, use that - otherwise fetch it\n        if (typeof chainId !== \"undefined\" || (chainSettings && typeof chainSettings.chainId !== \"undefined\")) {\n            this.chainId = chainId || chainSettings.chainId;\n            this.initialized = Promise.resolve();\n        }\n        else {\n            this.initialized = this.initialize();\n        }\n        // EIP155 compliant transactions are enabled for hardforks later\n        // than or equal to \"spurious dragon\"\n        this.hardfork = (chainSettings && chainSettings.hardfork) ?\n            chainSettings.hardfork :\n            \"istanbul\";\n        const self = this;\n        this.engine.addProvider(new hooked_wallet_1.default({\n            getAccounts(cb) {\n                cb(null, tmpAccounts);\n            },\n            getPrivateKey(address, cb) {\n                if (!tmpWallets[address]) {\n                    return cb(\"Account not found\");\n                }\n                else {\n                    cb(null, tmpWallets[address].getPrivateKey().toString(\"hex\"));\n                }\n            },\n            signTransaction(txParams, cb) {\n                return __awaiter(this, void 0, void 0, function* () {\n                    yield self.initialized;\n                    // we need to rename the 'gas' field\n                    txParams.gasLimit = txParams.gas;\n                    delete txParams.gas;\n                    let pkey;\n                    const from = txParams.from.toLowerCase();\n                    if (tmpWallets[from]) {\n                        pkey = tmpWallets[from].getPrivateKey();\n                    }\n                    else {\n                        cb(\"Account not found\");\n                    }\n                    const chain = self.chainId;\n                    const KNOWN_CHAIN_IDS = new Set([1, 3, 4, 5, 42]);\n                    let txOptions;\n                    if (typeof chain !== \"undefined\" && KNOWN_CHAIN_IDS.has(chain)) {\n                        txOptions = { chain };\n                    }\n                    else if (typeof chain !== \"undefined\") {\n                        const common = ethereumjs_common_1.default.forCustomChain(1, {\n                            name: \"custom chain\",\n                            chainId: chain\n                        }, self.hardfork);\n                        txOptions = { common };\n                    }\n                    const tx = new ethereumjs_tx_1.Transaction(txParams, txOptions);\n                    tx.sign(pkey);\n                    const rawTx = `0x${tx.serialize().toString(\"hex\")}`;\n                    cb(null, rawTx);\n                });\n            },\n            signMessage({ data, from }, cb) {\n                const dataIfExists = data;\n                if (!dataIfExists) {\n                    cb(\"No data to sign\");\n                }\n                if (!tmpWallets[from]) {\n                    cb(\"Account not found\");\n                }\n                let pkey = tmpWallets[from].getPrivateKey();\n                const dataBuff = EthUtil.toBuffer(dataIfExists);\n                const msgHashBuff = EthUtil.hashPersonalMessage(dataBuff);\n                const sig = EthUtil.ecsign(msgHashBuff, pkey);\n                const rpcSig = EthUtil.toRpcSig(sig.v, sig.r, sig.s);\n                cb(null, rpcSig);\n            },\n            signPersonalMessage(...args) {\n                this.signMessage(...args);\n            }\n        }));\n        !shareNonce\n            ? this.engine.addProvider(new nonce_tracker_1.default())\n            : this.engine.addProvider(singletonNonceSubProvider);\n        this.engine.addProvider(new filters_1.default());\n        if (typeof providerOrUrl === \"string\") {\n            const url = providerOrUrl;\n            const providerProtocol = (url_1.default.parse(url).protocol || \"http:\").toLowerCase();\n            switch (providerProtocol) {\n                case \"ws:\":\n                case \"wss:\":\n                    this.engine.addProvider(new websocket_1.default({ rpcUrl: url }));\n                    break;\n                default:\n                    this.engine.addProvider(new rpc_1.default({ rpcUrl: url }));\n            }\n        }\n        else {\n            const provider = providerOrUrl;\n            this.engine.addProvider(new provider_1.default(provider));\n        }\n        // Required by the provider engine.\n        this.engine.start((err) => {\n            if (err)\n                throw err;\n        });\n    }\n    initialize() {\n        return new Promise((resolve, reject) => {\n            this.engine.sendAsync({\n                jsonrpc: '2.0',\n                id: Date.now(),\n                method: 'eth_chainId',\n                params: []\n            }, (error, response) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                else if (response.error) {\n                    reject(response.error);\n                    return;\n                }\n                if (isNaN(parseInt(response.result, 16))) {\n                    const message = \"When requesting the chain id from the node, it\" +\n                        `returned the malformed result ${response.result}.`;\n                    throw new Error(message);\n                }\n                this.chainId = parseInt(response.result, 16);\n                resolve();\n            });\n        });\n    }\n    // private helper to check if given mnemonic uses BIP39 passphrase protection\n    checkBIP39Mnemonic({ addressIndex, numberOfAddresses, phrase, password }) {\n        this.hdwallet = ethereumjs_wallet_2.hdkey.fromMasterSeed(bip39.mnemonicToSeedSync(phrase, password));\n        if (!bip39.validateMnemonic(phrase, english_1.wordlist)) {\n            throw new Error(\"Mnemonic invalid or undefined\");\n        }\n        // crank the addresses out\n        for (let i = addressIndex; i < addressIndex + numberOfAddresses; i++) {\n            const wallet = this.hdwallet\n                .derivePath(this.walletHdpath + i)\n                .getWallet();\n            const addr = `0x${wallet.getAddress().toString(\"hex\")}`;\n            this.addresses.push(addr);\n            this.wallets[addr] = wallet;\n        }\n    }\n    // private helper leveraging ethUtils to populate wallets/addresses\n    ethUtilValidation({ addressIndex, privateKeys }) {\n        // crank the addresses out\n        for (let i = addressIndex; i < privateKeys.length; i++) {\n            const privateKey = Buffer.from(privateKeys[i].replace(\"0x\", \"\"), \"hex\");\n            if (EthUtil.isValidPrivate(privateKey)) {\n                const wallet = ethereumjs_wallet_1.default.fromPrivateKey(privateKey);\n                const address = wallet.getAddressString();\n                this.addresses.push(address);\n                this.wallets[address] = wallet;\n            }\n        }\n    }\n    ;\n    send(payload, callback) {\n        this.initialized.then(() => {\n            this.engine.send(payload, callback);\n        });\n    }\n    sendAsync(payload, callback) {\n        this.initialized.then(() => {\n            this.engine.sendAsync(payload, callback);\n        });\n    }\n    getAddress(idx) {\n        if (!idx) {\n            return this.addresses[0];\n        }\n        else {\n            return this.addresses[idx];\n        }\n    }\n    getAddresses() {\n        return this.addresses;\n    }\n    static isValidProvider(provider) {\n        const validProtocols = [\"http:\", \"https:\", \"ws:\", \"wss:\"];\n        if (typeof provider === \"string\") {\n            const url = url_1.default.parse(provider.toLowerCase());\n            return !!(validProtocols.includes(url.protocol || \"\") && url.slashes);\n        }\n        return true;\n    }\n}\nmodule.exports = HDWalletProvider;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}