{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar createHash = _interopDefault(require('create-hash'));\n\nvar pbkdf2 = _interopDefault(require('pbkdf2'));\n\nvar randombytes = _interopDefault(require('randombytes'));\n\nfunction unwrapExports(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n  return module = {\n    exports: {}\n  }, fn(module, module.exports), module.exports;\n}\n\nvar emptyModule = /*#__PURE__*/Object.freeze({\n  __proto__: null\n});\nvar src = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  let DEFAULT_WORDLIST = emptyModule._default;\n  const INVALID_MNEMONIC = 'Invalid mnemonic';\n  const INVALID_ENTROPY = 'Invalid entropy';\n  const INVALID_CHECKSUM = 'Invalid mnemonic checksum';\n  const WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' + 'Please explicitly pass a 2048 word array explicitly.';\n\n  function lpad(str, padString, length) {\n    while (str.length < length) str = padString + str;\n\n    return str;\n  }\n\n  function binaryToByte(bin) {\n    return parseInt(bin, 2);\n  }\n\n  function bytesToBinary(bytes) {\n    return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');\n  }\n\n  function deriveChecksumBits(entropyBuffer) {\n    const ENT = entropyBuffer.length * 8;\n    const CS = ENT / 32;\n    const hash = createHash('sha256').update(entropyBuffer).digest();\n    return bytesToBinary([...hash]).slice(0, CS);\n  }\n\n  function salt(password) {\n    return 'mnemonic' + (password || '');\n  }\n\n  function mnemonicToSeedSync(mnemonic, password) {\n    const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n    const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n    return pbkdf2.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n  }\n\n  exports.mnemonicToSeedSync = mnemonicToSeedSync;\n\n  function mnemonicToSeed(mnemonic, password) {\n    return new Promise((resolve, reject) => {\n      try {\n        const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n        const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n        pbkdf2.pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', (err, data) => {\n          if (err) return reject(err);else return resolve(data);\n        });\n      } catch (error) {\n        return reject(error);\n      }\n    });\n  }\n\n  exports.mnemonicToSeed = mnemonicToSeed;\n\n  function mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = wordlist || DEFAULT_WORDLIST;\n\n    if (!wordlist) {\n      throw new Error(WORDLIST_REQUIRED);\n    }\n\n    const words = (mnemonic || '').normalize('NFKD').split(' ');\n    if (words.length % 3 !== 0) throw new Error(INVALID_MNEMONIC); // convert word indices to 11 bit binary strings\n\n    const bits = words.map(word => {\n      const index = wordlist.indexOf(word);\n      if (index === -1) throw new Error(INVALID_MNEMONIC);\n      return lpad(index.toString(2), '0', 11);\n    }).join(''); // split the binary string into ENT/CS\n\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex); // calculate the checksum and compare\n\n    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n    if (entropyBytes.length < 16) throw new Error(INVALID_ENTROPY);\n    if (entropyBytes.length > 32) throw new Error(INVALID_ENTROPY);\n    if (entropyBytes.length % 4 !== 0) throw new Error(INVALID_ENTROPY);\n    const entropy = Buffer.from(entropyBytes);\n    const newChecksum = deriveChecksumBits(entropy);\n    if (newChecksum !== checksumBits) throw new Error(INVALID_CHECKSUM);\n    return entropy.toString('hex');\n  }\n\n  exports.mnemonicToEntropy = mnemonicToEntropy;\n\n  function entropyToMnemonic(entropy, wordlist) {\n    if (!Buffer.isBuffer(entropy)) entropy = Buffer.from(entropy, 'hex');\n    wordlist = wordlist || DEFAULT_WORDLIST;\n\n    if (!wordlist) {\n      throw new Error(WORDLIST_REQUIRED);\n    } // 128 <= ENT <= 256\n\n\n    if (entropy.length < 16) throw new TypeError(INVALID_ENTROPY);\n    if (entropy.length > 32) throw new TypeError(INVALID_ENTROPY);\n    if (entropy.length % 4 !== 0) throw new TypeError(INVALID_ENTROPY);\n    const entropyBits = bytesToBinary([...entropy]);\n    const checksumBits = deriveChecksumBits(entropy);\n    const bits = entropyBits + checksumBits;\n    const chunks = bits.match(/(.{1,11})/g);\n    const words = chunks.map(binary => {\n      const index = binaryToByte(binary);\n      return wordlist[index];\n    });\n    return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n    ? words.join('\\u3000') : words.join(' ');\n  }\n\n  exports.entropyToMnemonic = entropyToMnemonic;\n\n  function generateMnemonic(strength, rng, wordlist) {\n    strength = strength || 128;\n    if (strength % 32 !== 0) throw new TypeError(INVALID_ENTROPY);\n    rng = rng || randombytes;\n    return entropyToMnemonic(rng(strength / 8), wordlist);\n  }\n\n  exports.generateMnemonic = generateMnemonic;\n\n  function validateMnemonic(mnemonic, wordlist) {\n    try {\n      mnemonicToEntropy(mnemonic, wordlist);\n    } catch (e) {\n      return false;\n    }\n\n    return true;\n  }\n\n  exports.validateMnemonic = validateMnemonic;\n\n  function setDefaultWordlist(language) {\n    const result = emptyModule.wordlists[language];\n    if (result) DEFAULT_WORDLIST = result;else throw new Error('Could not find wordlist for language \"' + language + '\"');\n  }\n\n  exports.setDefaultWordlist = setDefaultWordlist;\n\n  function getDefaultWordlist() {\n    if (!DEFAULT_WORDLIST) throw new Error('No Default Wordlist set');\n    return Object.keys(emptyModule.wordlists).filter(lang => {\n      if (lang === 'JA' || lang === 'EN') return false;\n      return emptyModule.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n    })[0];\n  }\n\n  exports.getDefaultWordlist = getDefaultWordlist;\n  var _wordlists_2 = emptyModule;\n  exports.wordlists = _wordlists_2.wordlists;\n});\nvar index = unwrapExports(src);\nvar src_1 = src.mnemonicToSeedSync;\nvar src_2 = src.mnemonicToSeed;\nvar src_3 = src.mnemonicToEntropy;\nvar src_4 = src.entropyToMnemonic;\nvar src_5 = src.generateMnemonic;\nvar src_6 = src.validateMnemonic;\nvar src_7 = src.setDefaultWordlist;\nvar src_8 = src.getDefaultWordlist;\nvar src_9 = src.wordlists;\nexports.default = index;\nexports.entropyToMnemonic = src_4;\nexports.generateMnemonic = src_5;\nexports.getDefaultWordlist = src_8;\nexports.mnemonicToEntropy = src_3;\nexports.mnemonicToSeed = src_2;\nexports.mnemonicToSeedSync = src_1;\nexports.setDefaultWordlist = src_7;\nexports.validateMnemonic = src_6;\nexports.wordlists = src_9;","map":{"version":3,"sources":["/Applications/MAMP/htdocs/blockchain_project/node_modules/ethereum-cryptography/vendor/bip39-without-wordlists.js"],"names":["Object","defineProperty","exports","value","_interopDefault","ex","createHash","require","pbkdf2","randombytes","unwrapExports","x","__esModule","prototype","hasOwnProperty","call","createCommonjsModule","fn","module","emptyModule","freeze","__proto__","src","DEFAULT_WORDLIST","_default","INVALID_MNEMONIC","INVALID_ENTROPY","INVALID_CHECKSUM","WORDLIST_REQUIRED","lpad","str","padString","length","binaryToByte","bin","parseInt","bytesToBinary","bytes","map","toString","join","deriveChecksumBits","entropyBuffer","ENT","CS","hash","update","digest","slice","salt","password","mnemonicToSeedSync","mnemonic","mnemonicBuffer","Buffer","from","normalize","saltBuffer","pbkdf2Sync","mnemonicToSeed","Promise","resolve","reject","err","data","error","mnemonicToEntropy","wordlist","Error","words","split","bits","word","index","indexOf","dividerIndex","Math","floor","entropyBits","checksumBits","entropyBytes","match","entropy","newChecksum","entropyToMnemonic","isBuffer","TypeError","chunks","binary","generateMnemonic","strength","rng","validateMnemonic","e","setDefaultWordlist","language","result","wordlists","getDefaultWordlist","keys","filter","lang","every","_wordlists_2","src_1","src_2","src_3","src_4","src_5","src_6","src_7","src_8","src_9","default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar createHash = _interopDefault(require('create-hash'));\nvar pbkdf2 = _interopDefault(require('pbkdf2'));\nvar randombytes = _interopDefault(require('randombytes'));\n\nfunction unwrapExports (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nfunction createCommonjsModule(fn, module) {\n\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n}\n\n\n\nvar emptyModule = /*#__PURE__*/Object.freeze({\n\t__proto__: null\n});\n\nvar src = createCommonjsModule(function (module, exports) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\nlet DEFAULT_WORDLIST = emptyModule._default;\nconst INVALID_MNEMONIC = 'Invalid mnemonic';\nconst INVALID_ENTROPY = 'Invalid entropy';\nconst INVALID_CHECKSUM = 'Invalid mnemonic checksum';\nconst WORDLIST_REQUIRED = 'A wordlist is required but a default could not be found.\\n' +\n    'Please explicitly pass a 2048 word array explicitly.';\nfunction lpad(str, padString, length) {\n    while (str.length < length)\n        str = padString + str;\n    return str;\n}\nfunction binaryToByte(bin) {\n    return parseInt(bin, 2);\n}\nfunction bytesToBinary(bytes) {\n    return bytes.map(x => lpad(x.toString(2), '0', 8)).join('');\n}\nfunction deriveChecksumBits(entropyBuffer) {\n    const ENT = entropyBuffer.length * 8;\n    const CS = ENT / 32;\n    const hash = createHash('sha256')\n        .update(entropyBuffer)\n        .digest();\n    return bytesToBinary([...hash]).slice(0, CS);\n}\nfunction salt(password) {\n    return 'mnemonic' + (password || '');\n}\nfunction mnemonicToSeedSync(mnemonic, password) {\n    const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n    const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n    return pbkdf2.pbkdf2Sync(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512');\n}\nexports.mnemonicToSeedSync = mnemonicToSeedSync;\nfunction mnemonicToSeed(mnemonic, password) {\n    return new Promise((resolve, reject) => {\n        try {\n            const mnemonicBuffer = Buffer.from((mnemonic || '').normalize('NFKD'), 'utf8');\n            const saltBuffer = Buffer.from(salt((password || '').normalize('NFKD')), 'utf8');\n            pbkdf2.pbkdf2(mnemonicBuffer, saltBuffer, 2048, 64, 'sha512', (err, data) => {\n                if (err)\n                    return reject(err);\n                else\n                    return resolve(data);\n            });\n        }\n        catch (error) {\n            return reject(error);\n        }\n    });\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    const words = (mnemonic || '').normalize('NFKD').split(' ');\n    if (words.length % 3 !== 0)\n        throw new Error(INVALID_MNEMONIC);\n    // convert word indices to 11 bit binary strings\n    const bits = words\n        .map(word => {\n        const index = wordlist.indexOf(word);\n        if (index === -1)\n            throw new Error(INVALID_MNEMONIC);\n        return lpad(index.toString(2), '0', 11);\n    })\n        .join('');\n    // split the binary string into ENT/CS\n    const dividerIndex = Math.floor(bits.length / 33) * 32;\n    const entropyBits = bits.slice(0, dividerIndex);\n    const checksumBits = bits.slice(dividerIndex);\n    // calculate the checksum and compare\n    const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);\n    if (entropyBytes.length < 16)\n        throw new Error(INVALID_ENTROPY);\n    if (entropyBytes.length > 32)\n        throw new Error(INVALID_ENTROPY);\n    if (entropyBytes.length % 4 !== 0)\n        throw new Error(INVALID_ENTROPY);\n    const entropy = Buffer.from(entropyBytes);\n    const newChecksum = deriveChecksumBits(entropy);\n    if (newChecksum !== checksumBits)\n        throw new Error(INVALID_CHECKSUM);\n    return entropy.toString('hex');\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n    if (!Buffer.isBuffer(entropy))\n        entropy = Buffer.from(entropy, 'hex');\n    wordlist = wordlist || DEFAULT_WORDLIST;\n    if (!wordlist) {\n        throw new Error(WORDLIST_REQUIRED);\n    }\n    // 128 <= ENT <= 256\n    if (entropy.length < 16)\n        throw new TypeError(INVALID_ENTROPY);\n    if (entropy.length > 32)\n        throw new TypeError(INVALID_ENTROPY);\n    if (entropy.length % 4 !== 0)\n        throw new TypeError(INVALID_ENTROPY);\n    const entropyBits = bytesToBinary([...entropy]);\n    const checksumBits = deriveChecksumBits(entropy);\n    const bits = entropyBits + checksumBits;\n    const chunks = bits.match(/(.{1,11})/g);\n    const words = chunks.map(binary => {\n        const index = binaryToByte(binary);\n        return wordlist[index];\n    });\n    return wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093' // Japanese wordlist\n        ? words.join('\\u3000')\n        : words.join(' ');\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction generateMnemonic(strength, rng, wordlist) {\n    strength = strength || 128;\n    if (strength % 32 !== 0)\n        throw new TypeError(INVALID_ENTROPY);\n    rng = rng || randombytes;\n    return entropyToMnemonic(rng(strength / 8), wordlist);\n}\nexports.generateMnemonic = generateMnemonic;\nfunction validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nexports.validateMnemonic = validateMnemonic;\nfunction setDefaultWordlist(language) {\n    const result = emptyModule.wordlists[language];\n    if (result)\n        DEFAULT_WORDLIST = result;\n    else\n        throw new Error('Could not find wordlist for language \"' + language + '\"');\n}\nexports.setDefaultWordlist = setDefaultWordlist;\nfunction getDefaultWordlist() {\n    if (!DEFAULT_WORDLIST)\n        throw new Error('No Default Wordlist set');\n    return Object.keys(emptyModule.wordlists).filter(lang => {\n        if (lang === 'JA' || lang === 'EN')\n            return false;\n        return emptyModule.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);\n    })[0];\n}\nexports.getDefaultWordlist = getDefaultWordlist;\nvar _wordlists_2 = emptyModule;\nexports.wordlists = _wordlists_2.wordlists;\n});\n\nvar index = unwrapExports(src);\nvar src_1 = src.mnemonicToSeedSync;\nvar src_2 = src.mnemonicToSeed;\nvar src_3 = src.mnemonicToEntropy;\nvar src_4 = src.entropyToMnemonic;\nvar src_5 = src.generateMnemonic;\nvar src_6 = src.validateMnemonic;\nvar src_7 = src.setDefaultWordlist;\nvar src_8 = src.getDefaultWordlist;\nvar src_9 = src.wordlists;\n\nexports.default = index;\nexports.entropyToMnemonic = src_4;\nexports.generateMnemonic = src_5;\nexports.getDefaultWordlist = src_8;\nexports.mnemonicToEntropy = src_3;\nexports.mnemonicToSeed = src_2;\nexports.mnemonicToSeedSync = src_1;\nexports.setDefaultWordlist = src_7;\nexports.validateMnemonic = src_6;\nexports.wordlists = src_9;\n"]},"metadata":{},"sourceType":"script"}